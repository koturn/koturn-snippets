include c.snip

delete class
delete main
delete p
delete try

snippet main
  int
  main(${1:int argc, const char* argv[]})
  {
    ${0};
    return EXIT_SUCCESS;
  }

snippet DllMain
  #if defined(_MSC_VER) || defined(__CYGWIN__) || defined(__MSYS__) || defined(__MINGW32__) || defined(__MINGW64__)
  #  if defined(__CYGWIN__) || defined(__MSYS__) || defined(__MINGW32__) || defined(__MINGW64__)
  BOOL APIENTRY
  DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved);
  #  endif  /* defined(__CYGWIN__) || defined(__MSYS__) || defined(__MINGW32__) || defined(__MINGW64__) */
  static void
  ${1:constructor}();

  static void
  ${2:destructor}();

  BOOL APIENTRY
  DllMain(HMODULE /* hModule */, DWORD ul_reason_for_call, LPVOID /* lpReserved */)
  {
    switch (ul_reason_for_call) {
      case DLL_PROCESS_ATTACH:
        $1();
        break;
      case DLL_THREAD_ATTACH:
        break;
      case DLL_THREAD_DETACH:
        break;
      case DLL_PROCESS_DETACH:
        $2();
        break;
    }
    return TRUE;
  }
  #elif defined(__GNUC__)
  __attribute__((constructor))
  static void
  $1();

  __attribute__((destructor))
  static void
  $2();
  #endif  /* defined(_MSC_VER) || defined(__CYGWIN__) || defined(__MSYS__) || defined(__MINGW32__) || defined(__MINGW64__) */

  static void
  $1()
  {

  }

  static void
  $2()
  {

  }

  ${0}

snippet cout
  std::cout << ${0} << std::endl;

snippet cout2
  std::cout << ${0} << '\n';

snippet cout_all
  if (!${1}.empty()) {
    std::copy(
      std::cbegin($1),
      std::prev(std::cend($1)),
      std::ostream_iterator<const decltype($1)::value_type&>{${2:std\:\:cout}, ${3:" "}});
    $2 << *std::crbegin($1) << "\n";
  }
  ${0}

snippet put
  std::cout.put(${0})

snippet cerr
  std::cerr << ${0} << std::endl;

snippet clog
  std::clog << ${0} << std::endl;

snippet cin
  std::cin >> ${0};

snippet cinn
  std::cin >> `join(split(input('Variables> '), ' '), ' >> ')`;

snippet endl
  std::cout << std::endl;

snippet flush
  std::cout << std::flush;
snippet init_cppio
  std::cin.tie(nullptr);
  std::ios::sync_with_stdio(false);
  ${0}

snippet precision
  std::fixed << std::setprecision(${1}) << ${0}

snippet setfill
  std::setw(${1:#:n}) << std::setfill(${2:'0'}) << ${0}

snippet fstream
  std::${1:fstream} ${2:fs}(${3:#:filename}${4:, std::ios::binary});
  if (!$2.is_open()) {
    ${5:std\:\:cerr << "Failed to open\: " << $3 << std\:\:endl;}
  }
  ${0}

snippet read_all
  std::string ${1:text}{(std::istreambuf_iterator<char>{${2:#:stream}}), std::istreambuf_iterator<char>{}}

snippet sleep
  std::this_thread::sleep_for(std::chrono::${1:milliseconds}{${2:1000}});

snippet get_datetime
  const auto ${2:start} = std::chrono::${1:high_resolution_clock}::now();
  const auto ${3:tick} = std::chrono::$1::to_time_t($2);
  const auto ${4:datetime} = std::localtime(&$3);
  const auto ${5:d} = $2.time_since_epoch();
  const auto ${6:ms} = (std::chrono::duration_cast<std::chrono::milliseconds>($5) - std::chrono::duration_cast<std::chrono::seconds>($5)).count();
  // std::printf(
  //   // "%04d/%02d/%02d %02d:%02d:%02d.%03lld\n"
  //   "%04" PRId32 "/%02" PRId32 "/%02" PRId32 " %02" PRId32 ":%02" PRId32 ":%02" PRId32 ".%03" PRId64 ": %\n",  // <cinttypes>
  //   datetime->tm_year + 1900,
  //   datetime->tm_mon + 1,
  //   datetime->tm_mday,
  //   datetime->tm_hour,
  //   datetime->tm_min,
  //   datetime->tm_sec,
  //   ms);
  ${0}


snippet toppop
  ${1:#:Type} ${2:#:e} = ${3:#:queue}.top(); $3.pop();

snippet itrrange
  std::begin(${1}), std::end($1)

delete namespace
snippet namespace
  namespace ${1}
  {

  ${0}

  }  // namespace $1

snippet class
  class ${1:#:ClassName}
  {
    $1() noexcept${0}
  };  // class $1

snippet crtp_base
  template<typename ${1:T}>
  class ${2:#:ClassName}
  {
    ${0}
  };  // class $2

snippet crtp_derived
  class ${1:#:DerivedClassName}
    : public ${2:#:BaseClassName}<$1>
  {
    friend class $2<$1>;

    ${0}
  };  // class $1

snippet constructor
alias ctor
  ${1:#:ClassName}() noexcept ${0}

snippet copy_constructor
alias copy_ctor
  ${1:#:ClassName}(const $1& ${2:that}) ${0}

snippet move_constructor
alias move_ctor
  ${1:#:ClassName}($1&& ${2:that}) noexcept ${0}

snippet destructor
alias dtor
  ~${1:#:ClassName}() ${0}

snippet op_assign
  ${1:#:ClassName}& operator=(const $1&) ${0};

snippet op_move_assign
  ${1:#:ClassName}& operator=($1&&) noexcept ${0};

snippet op_ostream
  template<typename CharT, typename Traits>
  friend std::basic_ostream<CharT, Traits>&
  operator<<(std::basic_ostream<CharT, Traits>& ${1:os}, const ${2:#:ClassName}& ${3:this_})
  {
    return $1;
  }

snippet op_istream
  template<typename CharT, typename Traits>
  friend std::basic_istream<CharT, Traits>&
  operator>>(std::basic_istream<CharT, Traits>& ${1:is}, ${2:#:ClassName}& ${3:this_})
  {
    return $1;
  }

snippet numeric_limits
  std::numeric_limits<${1:int}>::${2}()${0}

snippet unique_ptr
abbr std::unique_ptr<T> <memory>
  std::unique_ptr<${1}> ${2}(new $1 ${0})

snippet shared_ptr
abbr std::shared_ptr<T> <memory>
  std::shared_ptr<${1}> ${2}(new $1 ${0})

snippet make_unique
abbr std::make_unique<T>(...) <memory>
  std::make_unique<${1}>(${0})

snippet make_shared
abbr std::make_shared<T>(...) <memory>
  std::make_shared<${1}>(${0})

snippet foreach_iterator
  for (std::${1:vector}<${2}>::iterator ${3:itr} = ${4}.begin(); $3 != $4.end(); ++$3) {
    ${0}
  }

snippet string
abbr std::string <string>
  std::string ${0}

snippet complex
abbr std::complex<T> <complex>
  std::complex<${1:double}> ${0}

snippet array
abbr std::array<T, N> <array>
  std::array<${1:int}, ${2:#:N}> ${0}

snippet vector
abbr std::vector<T> <vector>
  std::vector<${1:int}> ${0}

snippet valarray
abbr std::valarray<T> <valarray>
  std::valarray<${1:int}> ${0}

snippet bitset
abbr std::bitset<N> <bitset>
  std::bitset<${1:8}> ${0}

snippet list
abbr std::list<T> <list>
  std::list<${1:int}> ${0}

snippet forward_list
abbr std::forward_list<T> <forward_list>
  std::forward_list<${1:int}> ${0}

snippet deque
abbr std::deque<T> <deque>
  std::deque<${1:int}> ${0}

snippet stack
abbr std::stack<T> <stack>
  std::stack<${1:int}> ${0}

snippet queue
abbr std::queue<T> <queue>
  std::queue<${1:int}> ${0}

snippet priority_queue
abbr std::priority_queue<T> <queue>
  std::priority_queue<${1:int}> ${0}

snippet priority_queue2
abbr std::priority_queue<T> <queue>
  auto ${1:f} = [](const $5& ${2:x}, const $5& ${3:y}){
    return ${4:$2 > $3};
  };
  std::priority_queue<${5:int}, std::vector<$5>, decltype($1)> ${0}($1);

snippet map
abbr std::map<K, V> <map>
  std::map<${1:int}, ${2:int}> ${0}

snippet unordered_map
abbr std::unordered_map<K, V> <unordered_map>
  std::unordered_map<${1:int}, ${2:int}> ${0}

snippet multimap
abbr std::multimap<K, V> <map>
  std::multimap<${1:int}, ${2:int}> ${0}

snippet unordered_multimap
abbr std::unordered_multimap<K, V> <unordered_map>
  std::unordered_multimap<${1:int}, ${2:int}> ${0}

snippet set
abbr std::set<T> <set>
  std::set<${1:int}> ${0}

snippet unordered_set
abbr std::unordered_set<T> <unordered_set>
  std::unordered_set<${1:int}> ${0}

snippet multiset
abbr std::multiset<T> <set>
  std::multiset<${1:int}> ${0}

snippet unordered_multiset
abbr std::unordered_multiset<T> <unordered_set>
  std::unordered_multiset<${1:int}> ${0}

snippet pair
abbr std::pair<T1, T2> <utility>
  std::pair<${1:int}, ${2:int}> ${0}

snippet initializer_list
abbr std::initializer_list<T> <initializer_list>
  std::initializer_list<${1:int}> ${0}

snippet array2d
abbr std::array<std::array<T, W>, H> <array>
  std::array<std::array<${1:int}, ${3:#:W}>, ${2:#:H}> ${0}

snippet vector2d
abbr std::vector<std::vector<T> > <vector>
  std::vector<std::vector<${1:int}> > ${2:#:varname}(${3:#:height}, std::vector<$1>(${4:#:width}))

snippet valarray2d
abbr std::vector<std::valarray<T> > <valarray>
  std::vector<std::valarray<${1:int}> > ${2:#:varname}(${3:#:height}, std::valarray<$1>(${4:#:width}))

snippet random
  std::${1:mt19937} ${2:rnd}{std::random_device{}()}

snippet forward
  std::forward<${2:decltype($1)}>(${1})

snippet is_void
  std::is_void<${1}>::value

snippet is_void_v
  std::is_void_v<${1}>

snippet is_null_pointer
  std::is_null_pointer<${1}>::value

snippet is_null_pointer_v
  std::is_null_pointer_v<${1}>

snippet is_integral
  std::is_integral<${1}>::value

snippet is_integral_v
  std::is_integral_v<${1}>

snippet is_floating_point
  std::is_floating_point<${1}>::value

snippet is_floating_point_v
  std::is_floating_point_v<${1}>

snippet is_array
  std::is_array<${1}>::value

snippet is_array_v
  std::is_array_v<${1}>

snippet is_pointer
  std::is_pointer<${1}>::value

snippet is_pointer_v
  std::is_pointer_v<${1}>

snippet is_lvalue_reference
  std::is_lvalue_reference<${1}>::value

snippet is_lvalue_reference_v
  std::is_lvalue_reference_v<${1}>

snippet is_rvalue_reference
  std::is_rvalue_reference<${1}>::value

snippet is_member_object_pointer
  std::is_member_object_pointer<${1}>::value

snippet is_member_object_pointer_v
  std::is_member_object_pointer_v<${1}>

snippet is_member_function_pointer
  std::is_member_function_pointer<${1}>::value

snippet is_member_function_pointer_v
  std::is_member_function_pointer_v<${1}>

snippet is_enum
  std::is_enum<${1}>::value

snippet is_enum_v
  std::is_enum_v<${1}>

snippet is_union
  std::is_union<${1}>::value

snippet is_union_v
  std::is_union_v<${1}>

snippet is_class
  std::is_class<${1}>::value

snippet is_class_v
  std::is_class_v<${1}>

snippet is_function
  std::is_function<${1}>::value

snippet is_function_v
  std::is_function_v<${1}>

snippet is_reference
  std::is_reference<${1}>::value

snippet is_reference_v
  std::is_reference_v<${1}>

snippet is_arithmetic
  std::is_arithmetic<${1}>::value

snippet is_arithmetic_v
  std::is_arithmetic_v<${1}>

snippet is_fundamental
  std::is_fundamental<${1}>::value

snippet is_fundamental_v
  std::is_fundamental_v<${1}>

snippet is_object
  std::is_object<${1}>::value

snippet is_object_v
  std::is_object_v<${1}>

snippet is_scalar
  std::is_scalar<${1}>::value

snippet is_scalar_v
  std::is_scalar_v<${1}>

snippet is_compound
  std::is_compound<${1}>::value

snippet is_compound_v
  std::is_compound_v<${1}>

snippet is_member_pointer
  std::is_member_pointer<${1}>::value

snippet is_member_pointer_v
  std::is_member_pointer_v<${1}>

snippet is_const
  std::is_const<${1}>::value

snippet is_const_v
  std::is_const_v<${1}>

snippet is_volatile
  std::is_volatile<${1}>::value

snippet is_volatile_v
  std::is_volatile_v<${1}>

snippet is_trivial
  std::is_trivial<${1}>::value

snippet is_trivial_v
  std::is_trivial_v<${1}>

snippet is_trivially_copyable
  std::is_trivially_copyable<${1}>::value

snippet is_trivially_copyable_v
  std::is_trivially_copyable_v<${1}>

snippet is_standard_layout
  std::is_standard_layout<${1}>::value

snippet is_standard_layout_v
  std::is_standard_layout_v<${1}>

snippet is_pod
  std::is_pod<${1}>::value

snippet is_pod_v
  std::is_pod_v<${1}>

snippet is_literal_type
  std::is_literal_type<${1}>::value

snippet is_literal_type_v
  std::is_literal_type_v<${1}>

snippet is_empty
  std::is_empty<${1}>::value

snippet is_empty_v
  std::is_empty_v<${1}>

snippet is_polymorphic
  std::is_polymorphic<${1}>::value

snippet is_polymorphic_v
  std::is_polymorphic_v<${1}>

snippet is_abstract
  std::is_abstract<${1}>::value

snippet is_abstract_v
  std::is_abstract_v<${1}>

snippet is_final
  std::is_final<${1}>::value

snippet is_final_v
  std::is_final_v<${1}>

snippet is_signed
  std::is_signed<${1}>::value

snippet is_signed_v
  std::is_signed_v<${1}>

snippet is_unsigned
  std::is_unsigned<${1}>::value

snippet is_unsigned_v
  std::is_unsigned_v<${1}>

snippet is_constructible
  std::is_constructible<${1}>::value

snippet is_constructible_v
  std::is_constructible_v<${1}>

snippet is_default_constructible
  std::is_default_constructible<${1}>::value

snippet is_default_constructible_v
  std::is_default_constructible_v<${1}>

snippet is_copy_constructible
  std::is_copy_constructible<${1}>::value

snippet is_copy_constructible_v
  std::is_copy_constructible_v<${1}>

snippet is_move_constructible
  std::is_move_constructible<${1}>::value

snippet is_move_constructible_v
  std::is_move_constructible_v<${1}>

snippet is_assignable
  std::is_assignable<${1}>::value

snippet is_assignable_v
  std::is_assignable_v<${1}>

snippet is_copy_assignable
  std::is_copy_assignable<${1}>::value

snippet is_copy_assignable_v
  std::is_copy_assignable_v<${1}>

snippet is_move_assignable
  std::is_move_assignable<${1}>::value

snippet is_move_assignable_v
  std::is_move_assignable_v<${1}>

snippet is_destructible
  std::is_destructible<${1}>::value

snippet is_destructible_v
  std::is_destructible_v<${1}>

snippet is_trivially_constructible
  std::is_trivially_constructible<${1}>::value

snippet is_trivially_constructible_v
  std::is_trivially_constructible_v<${1}>

snippet is_trivially_default_constructible
  std::is_trivially_default_constructible<${1}>::value

snippet is_trivially_default_constructible_v
  std::is_trivially_default_constructible_v<${1}>

snippet is_trivially_copy_constructible
  std::is_trivially_copy_constructible<${1}>::value

snippet is_trivially_copy_constructible_v
  std::is_trivially_copy_constructible_v<${1}>

snippet is_trivially_move_constructible
  std::is_trivially_move_constructible<${1}>::value

snippet is_trivially_move_constructible_v
  std::is_trivially_move_constructible_v<${1}>

snippet is_trivially_assignable
  std::is_trivially_assignable<${1}>::value

snippet is_trivially_assignable_v
  std::is_trivially_assignable_v<${1}>

snippet is_trivially_copy_assignable
  std::is_trivially_copy_assignable<${1}>::value

snippet is_trivially_copy_assignable_v
  std::is_trivially_copy_assignable_v<${1}>

snippet is_trivially_move_assignable
  std::is_trivially_move_assignable<${1}>::value

snippet is_trivially_move_assignable_v
  std::is_trivially_move_assignable_v<${1}>

snippet is_trivially_destructible
  std::is_trivially_destructible<${1}>::value

snippet is_trivially_destructible_v
  std::is_trivially_destructible_v<${1}>

snippet is_nothrow_constructible
  std::is_nothrow_constructible<${1}>::value

snippet is_nothrow_constructible_v
  std::is_nothrow_constructible_v<${1}>

snippet is_nothrow_default_constructible
  std::is_nothrow_default_constructible<${1}>::value

snippet is_nothrow_default_constructible_v
  std::is_nothrow_default_constructible_v<${1}>

snippet is_nothrow_copy_constructible
  std::is_nothrow_copy_constructible<${1}>::value

snippet is_nothrow_copy_constructible_v
  std::is_nothrow_copy_constructible_v<${1}>

snippet is_nothrow_move_constructible
  std::is_nothrow_move_constructible<${1}>::value

snippet is_nothrow_move_constructible_v
  std::is_nothrow_move_constructible_v<${1}>

snippet is_nothrow_assignable
  std::is_nothrow_assignable<${1}>::value

snippet is_nothrow_assignable_v
  std::is_nothrow_assignable_v<${1}>

snippet is_nothrow_copy_assignable
  std::is_nothrow_copy_assignable<${1}>::value

snippet is_nothrow_copy_assignable_v
  std::is_nothrow_copy_assignable_v<${1}>

snippet is_nothrow_move_assignable
  std::is_nothrow_move_assignable<${1}>::value

snippet is_nothrow_move_assignable_v
  std::is_nothrow_move_assignable_v<${1}>

snippet is_nothrow_destructible
  std::is_nothrow_destructible<${1}>::value

snippet is_nothrow_destructible_v
  std::is_nothrow_destructible_v<${1}>

snippet has_virtual_destructor
  std::has_virtual_destructor<${1}>::value

snippet has_virtual_destructor_v
  std::has_virtual_destructor_v<${1}>

snippet is_same
  std::is_same<${1}>::value

snippet is_same_v
  std::is_same_v<${1}>

snippet is_base_of
  std::is_base_of<${1}>::value

snippet is_base_of_v
  std::is_base_of_v<${1}>

snippet is_convertible
  std::is_convertible<${1}>::value

snippet is_convertible_v
  std::is_convertible_v<${1}>

snippet remove_const
  std::remove_const<${1}>::type

snippet remove_const_t
  std::remove_const_t<${1}>

snippet remove_volatile
  std::remove_volatile<${1}>::type

snippet remove_volatile_t
  std::remove_volatile_t<${1}>

snippet remove_cv
  std::remove_cv<${1}>::type

snippet remove_cv_t
  std::remove_cv_t<${1}>

snippet add_const
  std::add_const<${1}>::type

snippet add_const_t
  std::add_const_t<${1}>

snippet add_volatile
  std::add_volatile<${1}>::type

snippet add_volatile_t
  std::add_volatile_t<${1}>

snippet add_cv
  std::add_cv<${1}>::type

snippet add_cv_t
  std::add_cv_t<${1}>

snippet remove_reference
  std::remove_reference<${1}>::type

snippet remove_reference_t
  std::remove_reference_t<${1}>

snippet add_lvalue_reference
  std::add_lvalue_reference<${1}>::type

snippet add_lvalue_reference_t
  std::add_lvalue_reference_t<${1}>

snippet add_rvalue_reference
  std::add_rvalue_reference<${1}>::type

snippet add_rvalue_reference_t
  std::add_rvalue_reference_t<${1}>

snippet make_signed
  std::make_signed<${1}>::type

snippet make_signed_t
  std::make_signed_t<${1}>

snippet make_unsigned
  std::make_unsigned<${1}>::type

snippet make_unsigned_t
  std::make_unsigned_t<${1}>

snippet remove_extent
  std::remove_extent<${1}>::type

snippet remove_extent_t
  std::remove_extent_t<${1}>

snippet remove_all_extents
  std::remove_all_extents<${1}>::type

snippet remove_all_extents_t
  std::remove_all_extents_t<${1}>

snippet add_pointer
  std::add_pointer<${1}>::type

snippet add_pointer_t
  std::add_pointer_t<${1}>

snippet remove_pointer
  std::remove_pointer<${1}>::type

snippet remove_pointer_t
  std::remove_pointer_t<${1}>

snippet aligned_storage
  std::aligned_storage<${1}>::type

snippet aligned_storage_t
  std::aligned_storage_t<${1}>

snippet aligned_union
  std::aligned_union<${1}>::type

snippet aligned_union_t
  std::aligned_union_t<${1}>

snippet decay
  std::decay<${1}>::type

snippet decay_t
  std::decay_t<${1}>

snippet enable_if
  typename std::enable_if<${0}, std::nullptr_t>::type = nullptr

snippet enable_if_t
  typename std::enable_if_t<${0}, std::nullptr_t> = nullptr

snippet conditional
  std::conditional<${1}>::type

snippet conditional_t
  std::conditional_t<${1}>

snippet common_type
  std::common_type<${1}>::type

snippet common_type_t
  std::common_type_t<${1}>

snippet underlying_type
  std::underlying_type<${1}>::type

snippet underlying_type_t
  std::underlying_type_t<${1}>

snippet result_of
  std::result_of<${1}>::type

snippet result_of_t
  std::result_of_t<${1}>

snippet thread
  std::thread ${1:#:name}{[${2:&}]{
    ${0}
  }};

snippet async
  auto ${1:#:name} = std::async(std::launch::${2:async}, [${3:&}]{
    ${0}
  });

snippet join
  std::ostringstream ${1:oss};
  if (!${2}.empty()) {
    std::copy(std::cbegin($2), std::prev(std::cend($2)), std::ostream_iterator<const decltype($2)::value_type&>($1, ${3:","}));
    $1 << *std::crbegin($2);
  }
  ${0}

snippet join_to_string
  ${1}.empty() ? "" : std::accumulate(
    std::next(std::cbegin($1)),
    std::cend($1),
    std::to_string($1[0]),
    [](const std::string& ${2:acc}, const decltype($1)::value_type& ${3:e}) {
      return $2 + ${4:","} + std::to_string($3);
    })${0}

snippet split
  std::vector<std::string> ${1:tokens};
  std::string::size_type ${2:spos} = 0, ${3:epos}, ${4:delimlen} = sizeof(${5:","}) - 1;
  while (($3 = ${6:#:string}.find_first_of(",", $2)) != std::string::npos) {
    $1.emplace_back($6.substr($2, $3 - $2));
    $2 = $3 + $4;
  }
  $1.emplace_back($6.substr($2));
  ${0}

snippet split_by_char
  std::vector<std::string> ${1:tokens};
  std::istringstream ${2:iss}{${3:#:string}};
  for (std::string ${4:token}; std::getline($2, $4, ${5:','});) {
    $1.push_back($4);
  }
  ${0}

snippet regex
  std::regex ${1:#:name}{"${2:#:pattern}"};

snippet regex_match_loop
  for (std::sregex_iterator ${1:itr}{std::cbegin(${2:#:text}), std::cend($2), ${3:#:regex}}, ${4:end}; $1 != $4; ++$1) {
    ${0}
  }

snippet regex_split_loop
  for (std::sregex_iterator ${1:itr}{std::cbegin(${2:#:text}), std::cend($2), ${3:#:regex}, -1}, ${4:end}; $1 != $4; ++$1) {
    ${0}
  }

snippet regex_match_container
  std::${1:vector}<std::string> ${2:#:name}{std::regex_token_iterator{std::cbegin(${3:#:text}), std::cend($3), ${4:#:regex}}, std::regex_token_iterator{}};

snippet regex_split_container
  std::${1:vector}<std::string> ${2:#:name}{std::regex_token_iterator{std::cbegin(${3:#:text}), std::cend($3), ${4:#:regex}, -1}, std::regex_token_iterator{}};

snippet regex_split_back_inserter
  std::copy(
    std::sregex_token_iterator{std::cbegin(${1:#:text}), std::cend($1), ${2:#:regex}},
    std::sregex_token_iterator{},
    std::back_inserter(${3}));

snippet regex_match_back_inserter
  std::copy(
    std::sregex_token_iterator{std::cbegin(${1:#:text}), std::cend($1), ${2:#:regex}, -1},
    std::sregex_token_iterator{},
    std::back_inserter(${3}));

snippet regex_replace
  std::regex_replace(${1:#:text}, std::regex("${2:#:pattern}"), "${3:#:after}");

snippet fn
  ${1:#:rettype}
  ${2:#:fucname}()${3: noexcept}
  {
    ${0}
  }

snippet fn_auto
  auto
  ${2:#:fucname}()${3: noexcept} -> ${1:#:rettype}
  {
    ${0}
  }

snippet for_stl
  for (decltype(${1:#:container})::size_type ${2:i} = ${3:0}; $2 < ${4:$1.size()}; $2++) {
    ${0}
  }

snippet foreach_const_iterator
  for (std::${1:vector}<${2}>::const_iterator ${3:itr} = ${4}.begin(); $3 != $4.end(); ++$3) {
    ${0}
  }

snippet foreach_typeof
abbr foreach_typeof (GNU only)
  for (typeof(${1}.begin()) ${2:itr} = $1.begin(); $2 != $1.end(); ++$2) {
    ${0}
  }

snippet forref
alias rbf
  for (auto&& ${1:e} : ${2:#:container}) {
    ${0}
  }

snippet forref_c
alias rbfc
  for (const auto& ${1:e} : ${2:#:container}) {
    ${0}
  }

snippet try
  try {
    ${0}
  } catch (${1:const std::exception&} ${2:e}) {
    ${3:std::cerr << $2.what() << std::endl;}
  }

snippet struct_function_object
abbr Functional object
  struct ${1}
  {
    ${2}
    operator()(${3}) const
    {
      ${0}
    }
  };

snippet class_functional_object
abbr Functional object
  class ${1}
  {
  public:
    ${2} operator()(${3}) const
    {
      ${0}
    }
  };

snippet min
  std::min(${1:#:x}, ${2:#:y})

snippet max
  std::max(${1:#:x}, ${2:#:y})

snippet for_each
abbr std::for_each <algorithm>
  std::for_each(
    std::begin(${1}),
    std::end($1),
    [](const auto& ${2:e}) {
      ${0}
    });

snippet for_each11
abbr std::for_each <algorithm>
  std::for_each(
    std::begin(${1}),
    std::end($1),
    [](const decltype($1)::value_type& ${2:e}) {
      ${0}
    });

snippet all_of
abbr std::all_of <algorithm>
  std::all_of(
    std::cbegin(${1}),
    std::cend($1),
    [](const auto& ${2:e}) {
      return ${0};
    });

snippet all_of11
abbr std::all_of <algorithm>
  std::all_of(
    std::begin(${1}),
    std::end($1),
    [](const decltype($1)::value_type& ${2:e}) {
      return ${0};
    });

snippet none_of
abbr std::none_of <algorithm>
  std::none_of(
    std::cbegin(${1}),
    std::cend($1),
    [](const auto& ${2:e}) {
      return ${0};
    });

snippet none_of11
abbr std::none_of <algorithm>
  std::none_of(
    std::begin(${1}),
    std::end($1),
    [](const decltype($1)::value_type& ${2:e}) {
      return ${0};
    });

snippet any_of
abbr std::any_of <algorithm>
  std::any_of(
    std::cbegin(${1}),
    std::cend($1),
    [](const auto& ${2:e}) {
      return ${0};
    });

snippet any_of11
abbr std::any_of <algorithm>
  std::any_of(
    std::begin(${1}),
    std::end($1),
    [](const decltype($1)::value_type& ${2:e}) {
      return ${0};
    });

snippet sort
abbr std::sort <algorithm>
  std::sort(std::begin(${1}), std::end($1))

snippet sort_f
abbr std::sort <algorithm>
  std::sort(
    std::begin(${1}),
    std::end($1),
    [](const auto& ${2:x}, const auto& ${3:y}) {
      return ${0:$2 < $3};
    });

snippet sort_f11
abbr std::sort <algorithm>
  std::sort(
    std::begin(${1}),
    std::end($1),
    [](const decltype($1)::value_type& ${2:x}, const decltype($1)::value_type& ${3:y}) {
      return ${0:$2 < $3};
    });

snippet stable_sort
abbr std::stable_sort <algorithm>
  std::stable_sort(std::begin(${1}), std::end($1))

snippet stable_sort_f
abbr std::stable_sort <algorithm>
  std::stable_sort(
    std::begin(${1}),
    std::end($1),
    [](const auto& ${2:x}, const auto& ${3:x}) {
      return ${0:$2 < $3};
    });

snippet stable_sort_f11
abbr std::stable_sort <algorithm>
  std::stable_sort(
    std::begin(${1}),
    std::end($1),
    [](const decltype($1)::value_type& ${2:x}, const decltype($1)::value_type& ${3:y}) {
      return ${0:$2 < $3};
    });

snippet shuffle
abbr std::shuffle <algorithm> <random>
  std::shuffle(std::begin(${1}), std::end($1), ${2:std\:\:mt19937{}})

snippet partial_sum
abbr std::partial_sum <numeric>
  std::partial_sum(std::cbegin(${1}), std::cend($1), std::begin(${2}));

snippet partial_sum11
abbr std::partial_sum <numeric>
  std::partial_sum(std::begin(${1}), std::end($1), std::begin(${2}));

snippet min_element
abbr std::min_element <algorithm>
  std::min_element(std::cbegin(${1}), std::cend($1))

snippet min_element11
abbr std::min_element <algorithm>
  std::min_element(std::begin(${1}), std::end($1))

snippet min_element_f
abbr std::min_element <algorithm>
  std::min_element(
    std::begin(${1}),
    std::end($1),
    [](const auto& ${2:x}, const auto& ${3:y}) {
      return ${0:$2 < $3};
    });

snippet min_element_f11
abbr std::min_element <algorithm>
  std::min_element(
    std::begin(${1}),
    std::end($1),
    [](const decltype($1)::value_type& ${2:x}, const decltype($1)::value_type& ${3:y}) {
      return ${0:$2 < $3};
    });

snippet max_element
abbr std::max_element <algorithm>
  std::max_element(std::cbegin(${1}), std::cend($1))

snippet max_element11
abbr std::max_element <algorithm>
  std::max_element(std::begin(${1}), std::end($1))

snippet max_element_f
abbr std::max_element <algorithm>
  std::max_element(
    std::cbegin(${1}),
    std::cend($1),
    [](const auto& ${2:x}, const auto& ${3:y}) {
      return ${0:$2 < $3};
    });

snippet max_element_f11
abbr std::max_element <algorithm>
  std::max_element(
    std::begin(${1}),
    std::end($1),
    [](const decltype($1)::value_type& ${2:x}, const decltype($1)::value_type& ${3:y}) {
      return ${0:$2 < $3};
    });

snippet minmax_element
abbr std::minmax_element <algorithm>
  std::minmax_element(std::cbegin(${1}), std::cend($1))

snippet minmax_element11
abbr std::minmax_element <algorithm>
  std::minmax_element(std::begin(${1}), std::end($1))

snippet minmax_element_f
abbr std::minmax_element <algorithm>
  std::minmax_element(
    std::cbegin(${1}),
    std::cend($1),
    [](const auto& ${2:x}, const auto& ${3:y}) {
      return ${0:$2 < $3};
    });

snippet minmax_element_f11
abbr std::minmax_element <algorithm>
  std::minmax_element(
    std::begin(${1}),
    std::end($1),
    [](const decltype($1)::value_type& ${2:x}, const decltype($1)::value_type& ${3:y}) {
      return ${0:$2 < $3};
    });

snippet iota
abbr std::iota <numeric>
  std::iota(std::begin(${1}), std::end($1), ${2:0})

snippet generate
alias generate_f
abbr std::generate <algorithm>
  std::generate(
    std::begin(${1}),
    std::end($1),
    []{
      return ${0};
    });

snippet generate_n
alias generate_n_f
  std::generate(
    ${1:#:begin},
    ${2:#:size},
    []{
      return ${0};
    });

snippet fill_random
  std::generate(std::begin(${1}), std::end($1), std::${2:mt19937}{std::random_device{}()});

snippet fill
abbr std::fill <algorithm>
  std::fill(std::begin(${1}), std::end($1), ${2:#:0})

snippet fill_n
abbr std::fill_n <algorithm>
  std::fill_n(${1:#:begin}, ${2:#:size}, ${3:#:0})

snippet count
abbr std::count <algorithm>
  std::count(std::cbegin(${1}), std::cend($1), ${2:#:value})

snippet count11
abbr std::count <algorithm>
  std::count(std::begin(${1}), std::end($1), ${2:#:value})

snippet count_if
alias count_f
abbr std::count_if <algorithm>
  std::count_if(
    std::cbegin(${1}),
    std::cend($1),
    [](const auto& ${2:e}) {
      return ${0};
    });

snippet count_if11
alias count_p11
abbr std::count_if <algorithm>
  std::count_if(
    std::begin(${1}),
    std::end($1),
    [](const decltype($1)::value_type& ${2:e}) {
      return ${0};
    });

snippet equal
abbr std::equal <algorithm>
  std::equal(std::cbegin(${1}), std::cend($1), std::cbegin($2));

snippet equal11
abbr std::equal <algorithm>
  std::equal(std::begin(${1}), std::end($1), std::begin($2));

snippet equal_f
abbr std::equal <algorithm>
  std::equal(
    std::cbegin(${1}),
    std::cend($1),
    std::cbegin($2),
    [](const auto& ${3:x}, const auto& ${4:y}) {
      return ${0:$3 == $4};
    });

snippet equal_f11
abbr std::equal <algorithm>
  std::equal(
    std::begin(${1}),
    std::end($1),
    std::begin($2),
    [](const decltype($1)::value_type& ${3:x}, const decltype($2)::value_type& ${4:y}) {
      return ${0:$3 == $4};
    });

snippet find
abbr std::find <algorithm>
  std::find(std::cbegin(${1}), std::cend($1), ${2:#:value})

snippet find11
abbr std::find <algorithm>
  std::find(std::begin(${1}), std::end($1), ${2:#:value})

snippet find_if
alias find_f
abbr std::find_if <algorithm>
  std::find_if(
    std::cbegin(${1}),
    std::cend($1),
    [](const auto& ${2:e}) {
      return ${0};
    });

snippet find_if11
alias find_f11
abbr std::find_if <algorithm>
  std::find_if(
    std::begin(${1}),
    std::end($1),
    [](const decltype($1)::value_type& ${2:e}) {
      return ${0};
    });

snippet lower_bound
abbr std::lower_bound <algorithm>
  std::lower_bound(std::cbegin(${1}), std::cend($1), ${2:#:value});

snippet lower_bound11
abbr std::lower_bound <algorithm>
  std::lower_bound(std::begin(${1}), std::end($1), ${2:#:value});

snippet lower_bound_f
abbr std::lower_bound <algorithm>
  std::lower_bound(
    std::cbegin(${1}),
    std::cend($1),
    ${2:#:value},
    [](const auto& ${3:e}) {
      return ${0};
    });

snippet lower_bound_f11
abbr std::lower_bound <algorithm>
  std::lower_bound(
    std::begin(${1}),
    std::end($1),
    ${2:#:value},
    [](const decltype($1)::value_type& ${3:e}) {
      return ${0};
    });

snippet upper_bound
abbr std::upper_bound <algorithm>
  std::upper_bound(std::cbegin(${1}), std::cend($1), ${2:#:value});

snippet upper_bound11
abbr std::upper_bound <algorithm>
  std::upper_bound(std::begin(${1}), std::end($1), ${2:#:value});

snippet upper_bound_f
abbr std::upper_bound <algorithm>
  std::upper_bound(
    std::cbegin(${1}),
    std::cend($1),
    ${2:#:value},
    [](const auto& ${3:e}) {
      return ${0};
    });

snippet upper_bound_f11
abbr std::upper_bound <algorithm>
  std::upper_bound(
    std::begin(${1}),
    std::end($1),
    ${2:#:value},
    [](const decltype($1)::value_type& ${3:e}) {
      return ${0};
    });

snippet remove
abbr std::remove <algorithm>
  std::remove(std::begin(${1}), std::end($1), ${2:#:value})

snippet remove_if
alias remove_f
abbr std::remove_if <algorithm>
  std::remove_if(
    std::begin(${1}),
    std::end($1),
    [](const auto& ${2:e}) {
      return ${0};
    });

snippet remove_if11
alias remove_f11
abbr std::remove_if <algorithm>
  std::remove_if(
    std::begin(${1}),
    std::end($1),
    [](const decltype($1)::value_type& ${2:e}) {
      return ${0};
    });

snippet remove_erase
  ${1}.erase(std::remove(std::begin($1), std::end($1), ${2:#:value}), std::end($1));

snippet remove_erase_if
alias remove_erase_p filter select
  ${1}.erase(
    std::remove_if(
      std::begin($1),
      std::end($1),
      [](const auto& ${2:e}) {
        return ${0};
      }),
    std::end($1));

snippet remove_erase_if11
alias remove_erase_p11 filter11 select11
  ${1}.erase(
    std::remove_if(
      std::begin($1),
      std::end($1),
      [](const decltype($1)::value_type& ${2:e}) {
        return ${0};
      }),
    std::end($1));

snippet search
  std::search(
    std::cbegin(${1}),
    std::cend($1),
    std::cbegin(${2}),
    std::cend($2));

snippet search11
  std::search(
    std::begin(${1}),
    std::end($1),
    std::begin(${2}),
    std::end($2));

snippet search_f
  std::search(
    std::cbegin(${1}),
    std::cend($1),
    std::cbegin(${2}),
    std::cend($2),
    [](const auto& ${3:x}, const auto& ${4:y}) {
      return ${0:$3 == $4};
    });

snippet search_f11
  std::search(
    std::begin(${1}),
    std::end($1),
    std::begin(${2}),
    std::end($2),
    [](const auto& ${3:x}, const auto& ${4:y}) {
      return ${0:$3 == $4};
    });

snippet set_union
  std::set_union(
    std::cbegin(${1}),
    std::cend($1),
    std::cbegin(${2}),
    std::cend($2),
    std::begin(${3}));

snippet set_union11
  std::set_union(
    std::begin(${1}),
    std::end($1),
    std::begin(${2}),
    std::end($2),
    std::begin(${3}));

snippet set_union_f
  std::set_union(
    std::cbegin(${1}),
    std::cend($1),
    std::cbegin(${2}),
    std::cend($2),
    std::begin(${3}),
    [](const auto& ${4:x}, const auto& ${5:y}) {
      return ${0:$4 == $5};
    });

snippet set_union_f11
  std::set_union(
    std::begin(${1}),
    std::end($1),
    std::begin(${2}),
    std::end($2),
    std::begin(${3}),
    [](const decltype($1)::value_type& ${4:x}, const decltype($1)::value_type& ${5:y}) {
      return ${0:$4 == $5};
    });

snippet unique
abbr std::unique <algorithm>
  std::unique(std::begin(${1}), std::end($1))

snippet unique_f
abbr std::unique <algorithm>
  std::unique(
    std::begin(${1}),
    std::end($1),
    [](const auto& ${2:x}, const auto& ${3:y}) {
      return ${0:$2 == $3};
    });

snippet unique_f11
abbr std::unique <algorithm>
  std::unique(
    std::begin(${1}),
    std::end($1),
    [](const decltype($1)::value_type& ${2:x}, const decltype($1)::value_type& ${3:y}) {
      return ${0:$2 == $3};
    });

snippet unique_erase
  ${1}.erase(std::unique(std::begin($1), std::end($1)), std::end($1));

snippet unique_erase_f
  ${1}.erase(
    std::unique(
      std::begin($1),
      std::end($1),
      [](const auto& ${2:x}, const auto& ${3:y}) {
        return ${0:$2 == $3};
      }),
    std::end($1));

snippet unique_erase_f11
  ${1}.erase(
    std::unique(
      std::begin($1),
      std::end($1),
      [](const decltype($1)::value_type& ${2:x}, const decltype($1)::value_type& ${3:y}) {
        return ${0:$2 == $3};
      }),
    std::end($1));

snippet copy
abbr std::copy <algorithm>
  std::copy(std::cbegin(${1}), std::cend($1), std::begin(${2}))

snippet copy11
abbr std::copy <algorithm>
  std::copy(std::begin(${1}), std::end($1), std::begin(${2}))

snippet copy_back_inserter
abbr std::copy_back_inserter <algorithm>
  std::copy(std::cbegin(${1}), std::cend($1), std::back_inserter(${2}))

snippet copy_back_inserter11
abbr std::copy_back_inserter <algorithm>
  std::copy(std::begin(${1}), std::end($1), std::back_inserter(${2}))

snippet copy_backward
abbr std::copy_backword <algorithm>
  std::copy_backward(std::cbegin(${1}), std::cend($1), std::end(${2}))

snippet copy_backward11
abbr std::copy_backword <algorithm>
  std::copy_backward(std::begin(${1}), std::end($1), std::end(${2}))

snippet copy_n
abbr std::copy_n <algorithm>
  std::copy_n(std::cbegin(${1}), ${2:#:size}, std::begin(${3}))

snippet copy_n11
abbr std::copy_n <algorithm>
  std::copy_n(std::begin(${1}), ${2:#:size}, std::begin(${3}))

snippet copy_n_back_inserter
abbr std::copy_n_back_inserter <algorithm>
  std::copy_n(std::cbegin(${1}), ${2:#:size}, std::back_inserter(${3}))

snippet copy_n_back_inserter11
abbr std::copy_n_back_inserter <algorithm>
  std::copy_n(std::begin(${1}), ${2:#:size}, std::back_inserter(${3}))

snippet copy_if
alias copy_f
abbr std::copy_if <algorithm>
  std::copy_if(
    std::cbegin(${1}),
    std::cend($1),
    std::begin(${2}),
    [](const auto& ${3:e}) {
      return ${0};
    });

snippet copy_if11
alias copy_f11
abbr std::copy_if <algorithm>
  std::copy_if(
    std::begin(${1}),
    std::end($1),
    std::begin(${2}),
    [](const decltype($1)::value_type& ${3:e}) {
      return ${0};
    });

snippet copy_if_back_inserter
alias copy_p_back_inserter
abbr std::copy_if_back_inserter <algorithm>
  std::copy_if(
    std::cbegin(${1}),
    std::cend($1),
    std::back_inserter(${2}),
    [](const auto& ${3:e}) {
      return ${0};
    });

snippet copy_if_back_inserter11
alias copy_p_back_inserter11
abbr std::copy_if_back_inserter <algorithm>
  std::copy_if(
    std::begin(${1}),
    std::end($1),
    std::back_inserter(${2}),
    [](const decltype($1)::value_type& ${3:e}) {
      return ${0};
    });

snippet replace
abbr std::replace <algorithm>
  std::replace(std::begin(${1}), std::end($1), ${2:#:before}, ${3:#:after})

snippet replace_if
alias replace_f
abbr std::replace_if <algorithm>
  std::replace_if(
    std::begin(${1}),
    std::end($1),
    [](const auto& ${3:e}) {
      return ${0};
    }, ${2:#:after});

snippet replace_if11
alias replace_f11
abbr std::replace_if <algorithm>
  std::replace_if(
    std::begin(${1}),
    std::end($1),
    [](const decltype($1)::value_type& ${3:e}) {
      return ${0};
    }, ${2:#:after});

snippet reverse
  std::reverse(std::begin(${1}), std::end($1))

snippet rotate
  std::rotate(std::begin(${1}), std::next(std::begin($1), ${2:1}), std::end($1))

snippet sum
alias foldl
  std::accumulate(std::cbegin(${1}), std::cend($1), ${2:decltype($1)::value_type{}})

snippet sum11
alias foldl11
  std::accumulate(std::begin(${1}), std::end($1), ${2:decltype($1)::value_type{}})

snippet foldr
  std::accumulate(
    std::crbegin(${1}),
    std::crend($1),
    ${2:decltype($1)::value_type{}},
    [](const auto& ${3:acc}, const auto& ${4:e}) {
      return $4 + acc;
    });

snippet foldr11
  std::accumulate(
    std::rbegin(${1}),
    std::rend($1),
    ${2:decltype($1)::value_type{}},
    [](const decltype($1)::value_type& ${3:acc}, const decltype($1)::value_type& ${4:e}) {
      return $4 + acc;
    });

snippet accumulate
alias accumulate_f reduce
abbr std::acumulate <numeric>
  std::accumulate(
    std::cbegin(${1}),
    std::cend($1),
    ${2:decltype($1)::value_type{}},
    [](const auto& ${3:acc}, const auto& ${4:e}) {
      return ${5:$3 + $4};
    });

snippet accumulate11
alias accumulate_f11 reduce11
abbr std::acumulate <numeric>
  std::accumulate(
    std::begin(${1}),
    std::end($1),
    ${2:decltype($1)::value_type{}},
    [](const decltype($1)::value_type& ${3:acc}, const decltype($1)::value_type& ${4:e}) {
      return ${5:$3 + $4};
    });

snippet inner_product
abbr std::inner_product <numeric>
  std::inner_product(std::cbegin(${1}), std::cend($1), std::cbegin(${2}), ${3:decltype($1)::value_type{}})

snippet inner_product11
abbr std::inner_product <numeric>
  std::inner_product(std::begin(${1}), std::end($1), std::begin(${2}), ${3:decltype($1)::value_type{}})

snippet inner_product_f
abbr std::inner_product <numeric>
  std::inner_product(
    std::cbegin(${1}),
    std::cend($1),
    std::cbegin(${2}),
    ${3:decltype($1)::value_type{}}
    [](const auto& ${4:acc}, const auto& ${5:e}){
      return ${6:$4 + $5};
    },
    [](const auto& ${7:x}, const auto& ${8:y}){
      return ${9:$7 * $8};
    })${0}

snippet inner_product_f11
abbr std::inner_product <numeric>
  std::inner_product(
    std::cbegin(${1}),
    std::cend($1),
    std::cbegin(${2}),
    ${3:decltype($1)::value_type{}}
    [](const decltype($1)::value_type& ${4:acc}, const decltype($1)::value_type& ${5:e}){
      return ${6:$4 + $5};
    },
    [](const decltype($1)::value_type& ${7:x}, const decltype($2)::value_type& ${8:y}){
      return ${9:$7 * $8};
    })${0}

snippet transform
alias transform_f map_set select
abbr std::transform <algorithm>
  std::transform(
    std::cbegin(${1}),
    std::cend($1),
    std::begin(${2}),
    [](const auto& ${3:e}) {
      return ${0};
    });

snippet transform11
alias transform_f11 map_set11 select11
abbr std::transform <algorithm>
  std::transform(
    std::begin(${1}),
    std::end($1),
    std::begin(${2}),
    [](const decltype($1)::value_type& ${3:e}) {
      return ${0};
    });

snippet tolower_string
  std::transform(std::cbegin(${1}), std::cend($1), std::begin($1), static_cast<int (*)(int)>(std::tolower));

snippet tolower_string11
  std::transform(std::begin(${1}), std::end($1), std::begin($1), static_cast<int (*)(int)>(std::tolower));

snippet toupper_string
  std::transform(std::cbegin(${1}), std::cend($1), std::begin($1), static_cast<int (*)(int)>(std::toupper));

snippet toupper_string11
  std::transform(std::begin(${1}), std::end($1), std::begin($1), static_cast<int (*)(int)>(std::toupper));

snippet next_permutation
  do {
    ${0}
  } while (std::next_permutation(std::begin(${1}), std::end($1)));

snippet time_measurement
  const auto ${1:start} = std::chrono::${2:high_resolution_clock}::now();
  ${0};
  const auto ${3:elapsed} = std::chrono::duration_cast<std::chrono::${4:milliseconds}>(std::chrono::$2::now() - $1).count();

snippet duration_cast
abbr std::chrono::duration_cast<T>() <chrono>
  std::chrono::duration_cast<std::chrono::${1:milliseconds}>(${2})

snippet lock_guard
  {
    std::lock_guard<decltype($2)> ${1:lock}{${2:#:mutex}};
    ${0}
  }

snippet lock_guard_adopt
  {
    std::lock_guard<decltype($2)> ${1:lock}{${2:#:mutex}, std::adopt_lock};
    ${0}
  }

snippet update_min
  ${1:#:minValue} = std::min($1, ${2:#:newValue})

snippet update_max
  ${1:#:maxValue} = std::max($1, ${2:#:newValue})

snippet update_min_if
  if (${1:#:minValue} > ${2:#:newValue}) {
    $1 = $2;
    ${0}
  }

snippet update_max_if
  if (${1:#:maxValue} < ${2:#:newValue}) {
    $1 = $2;
    ${0}
  }

snippet impl_meta
  struct ${1:name}_impl
  {
    template<typename T>
    static auto
    check(${2}) -> decltype(${3}, std::true_type{});

    template<typename T>
    static auto
    check(...) -> std::false_type;
  };  // struct $1_impl

  template<typename T>
  class $1 :
    public decltype($1_impl::check(std::declval<T>())){};

snippet impl_type_metafunc_alias
  #if __cplusplus >= 201402L || defined(_MSVC_LANG) && _MSVC_LANG >= 201402L
  template<typename T>
  using ${1:name}_t = typename $1<T>::type;
  #endif  // __cplusplus >= 201402L || defined(_MSVC_LANG) && _MSVC_LANG >= 201402L

snippet impl_bool_metafunc_alias
  #if __cplusplus >= 201703L || defined(_MSVC_LANG) && _MSVC_LANG >= 201703L
  template<typename T>
  inline constexpr bool ${1:name}_v = $1<T>::value;
  #endif  // __cplusplus >= 201703L || defined(_MSVC_LANG) && _MSVC_LANG >= 201703L

snippet impl_ScopedStopWatch
  template<
    typename Duration = std::chrono::milliseconds,
    typename Clock = std::chrono::high_resolution_clock,
    typename F = std::function<std::int64_t(Duration, Clock)>
  >
  class ${1:ScopedStopWatch} : F
  {
  public:
    explicit $1(F&& f) noexcept
      : F(std::forward<F>(f))
      , m_start(Clock::now())
    {}

    ~$1()
    {
      F::operator()(std::chrono::duration_cast<Duration>(Clock::now() - m_start).count());
    }

  private:
    const typename Clock::time_point m_start;
  };  // class $1

  namespace
  {
  template<
    typename Duration = std::chrono::milliseconds,
    typename Clock = std::chrono::high_resolution_clock,
    typename F = std::function<std::int64_t(Duration, Clock)>
  >
  inline decltype(auto)
  make$1(F&& f) noexcept
  {
    return $1<Duration, Clock, F>{std::forward<F>(f)};
  }
  }  // namespace

  ${0}


snippet impl_fixpoint
  template<typename F>
  class ${1:FixPoint} : private F
  {
    using F::operator();

  public:
    explicit constexpr $1(F&& f) noexcept
      : F(std::forward<F>(f))
    {}

    template<typename... Args>
    constexpr decltype(auto)
    operator()(Args&&... args) const
    {
      return operator()(*this, std::forward<Args>(args)...);
    }
  };  // class $1

  namespace
  {
  template<typename F>
  inline constexpr decltype(auto)
  makeFixPoint(F&& f) noexcept
  {
    return $1<F>{std::forward<F>(f)};
  }
  }  // namespace

  ${0}


snippet impl_fixpoint_many
  #if __cplusplus >= 201703L || defined(_MSVC_LANG) && _MSVC_LANG >= 201703L
  template<typename... Fs>
  class ${1:FixPoint} : Fs...
  #else
  template<typename F>
  class $1 : F
  #endif  // __cplusplus >= 201703L || defined(_MSVC_LANG) && _MSVC_LANG >= 201703L
  {
  #if __cplusplus >= 201703L || defined(_MSVC_LANG) && _MSVC_LANG >= 201703L
    using Fs::operator()...;
  #else
    using F::operator();
  #endif  // __cplusplus >= 201703L || defined(_MSVC_LANG) && _MSVC_LANG >= 201703L

  public:
  #if __cplusplus >= 201703L || defined(_MSVC_LANG) && _MSVC_LANG >= 201703L
    explicit constexpr $1(Fs&&... fs) noexcept
      : Fs(std::forward<Fs>(fs))...
    {}
  #else
    explicit constexpr $1(F&& f) noexcept
      : F(std::forward<F>(f))
    {}
  #endif  // __cplusplus >= 201703L || defined(_MSVC_LANG) && _MSVC_LANG >= 201703L

    template<typename... Args>
    constexpr decltype(auto)
    operator()(Args&&... args) const
    {
      return operator()(*this, std::forward<Args>(args)...);
    }
  };  // class $1

  namespace
  {
  template<typename... Fs>
  inline constexpr decltype(auto)
  makeFixPoint(Fs&&... fs) noexcept
  {
    return $1<Fs...>{std::forward<Fs>(fs)...};
  }
  }  // namespace

  ${0}


snippet ycombinator
alias ycomb
  [](auto f) {
    return [=](auto&&... args) {
      return f(f, std::forward<decltype(args)>(args)...);
    };
  }([${1:&}](auto ${2:f}, ${3:#:args...}) {
    ${0}
  })

snippet zcombinator
alias zcomb
  [](auto f) {
    return [=](auto g) {
      return [=](auto&&... args) {
        return f(g(g), std::forward<decltype(args)>(args)...);
      };
    }([=](auto g) {
      return [=](auto&&... args) {
        return f(g(g), std::forward<decltype(args)>(args)...);
      };
    });
  }([${1:&}](auto ${2:f}, ${3:#:args...}) {
    ${0};
  })

snippet include
snippet inc
  #include <${0}>

snippet include_local
snippet incl
  #include "${0}"

snippet include_math
  #ifdef _MSC_VER
  #  define _USE_MATH_DEFINES
  #endif
  #include <cmath>

snippet include_guard
alias inc_guard
  #ifndef ${1:#:NAME}
  #define $1

  ${0}

  #endif  // $1

snippet extern_c
  #ifdef __cplusplus
  extern "C" {
  #endif  // __cplusplus

  ${0}

  #ifdef __cplusplus
  }
  #endif  // __cplusplus

snippet constant
  static constexpr ${1:int} ${2:#:varname} = ${3:#:value}

snippet LOOP
alias loop
  LOOP (${2:#:n}) {
    ${0}
  }

snippet REP
alias rep
  REP (${1:i}, ${2:#:n}) {
    ${0}
  }

snippet FOR
  FOR (${1:i}, ${2:#:from}, ${3:#:to}) {
    ${0}
  }

snippet def_dllexport
  #if defined(_MSC_VER) || defined(__CYGWIN__) || defined(__MSYS__) || defined(__MINGW32__) || defined(__MINGW64__)
  #  define ${1:#:NAME}_API_IMPORT __declspec(dllimport)
  #  define $1_API_EXPORT __declspec(dllexport)
  #  define $1_API_LOCAL
  #elif defined(__GNUC__) && __GNUC__ >= 4
  #  define $1_API_IMPORT __attribute__((visibility("default")))
  #  define $1_API_EXPORT __attribute__((visibility("default")))
  #  define $1_API_LOCAL  __attribute__((visibility("hidden")))
  #else
  #  define $1_API_IMPORT
  #  define $1_API_EXPORT
  #  define $1_API_LOCAL
  #endif  /* defined(_MSC_VER) || defined(__CYGWIN__) || defined(__MSYS__) || defined(__MINGW32__) || defined(__MINGW64__) */

  #ifdef $1_DLL
  #  ifdef $1_EXPORTS
  #    define $1_API $1_API_EXPORT
  #  else
  #    define $1_API $1_API_IMPORT
  #  endif  /* $1_EXPORTS */
  #  define $1_LOCAL $1_API_LOCAL
  #else
  #  define $1_API
  #  define $1_LOCAL
  #endif  /* $1_DLL */

  ${0}

  #undef $1_API_IMPORT
  #undef $1_API_EXPORT
  #undef $1_API_LOCAL
  #undef $1_API
  #undef $1_LOCAL

snippet def_LOOP
  #define LOOP(n)  for (decltype(n) __loop_tmp_var__ = 0; i < n; i++)

snippet def_REP
  #define REP(i, n)  for (decltype(n) i = 0; i < (n); i++)

snippet def_FOR
  #define FOR(i, from, to)  for (decltype(from) i = (from); i < (to); i++)

snippet def_CLEAR
  #define CLEAR(array)  std::memset((array), 0, sizeof(array))

snippet def_FILL
  #define FILL(array, val)  std::fill_n(array, LENGTH(array), val)

snippet def_enum
  #if __cplusplus >= 201103L
  enum class ${1:className}
  {
    ${2:enumValues}
  };  // enum class $1
  #else
  class $1
  {
  public:
    enum $1Enum
    {
      $2
    };
    $1()
    {}

    $1($1Enum value) :
      value(value)
    {}

    operator $1Enum() const throw()
    {
      return value;
    }
  private:
    $1Enum value;
  };  // class $1
  #endif  // __cplusplus >= 201103L

snippet def_debug_macros
  #ifdef _MSC_VER
  #  ifndef _DEBUG
  #    define _DEBUG
  #  endif
  #  define _CRTDBG_MAP_ALLOC
  #else
  #  define _FORTIFY_SOURCE 2
  #  define _GLIBCXX_DEBUG
  #endif

snippet def_INF
  static constexpr ${1:int} INF = 0x3f3f3f3f;

snippet def_EPS
  static constexpr double EPS = 1.0e-${1:9};

snippet def_M_PI
  #ifndef M_PI
  static const double M_PI = std::acos(0.0) * 2.0;
  #endif

snippet def_M_PI2
  #ifndef M_PI
  static const double M_PI = std::atan(1.0) * 4.0;
  #endif

snippet def_M_PI3
  #ifndef M_PI
  static constexpr double M_PI = 3.14159265358979323846;
  #endif

snippet def_DUMP
  #define DUMP(x)  (std::cout << #x " = " << x << std::endl)

snippet impl_LENGTH
abbr #define LENGTH
  namespace
  {
  template<typename ${1:T}, std::size_t ${2:kSize}>
  inline std::size_t
  LENGTH(const $1 (&)[$2])
  {
    return $2;
  }

  #if __cplusplus >= 201103L
  template<typename $1, std::size_t $2>
  inline constexpr typename std::array<$1, $2>::size_type
  LENGTH(const std::array<$1, $2>& ${3:array}) noexcept
  {
    return $3.size();
  }
  #endif // __cplusplus >= 201103L
  }  // namespace

snippet if_cpp11
  #if __cplusplus >= 201103L || defined(_MSVC_LANG) && _MSVC_LANG >= 201103L
  ${0}
  #endif  // __cplusplus >= 201103L || defined(_MSVC_LANG) && _MSVC_LANG >= 201103L

snippet if_cpp14
  #if __cplusplus >= 201402L || defined(_MSVC_LANG) && _MSVC_LANG >= 201402L
  ${0}
  #endif  // __cplusplus >= 201402L || defined(_MSVC_LANG) && _MSVC_LANG >= 201402L

snippet if_cpp17
  #if __cplusplus >= 201703L || defined(_MSVC_LANG) && _MSVC_LANG >= 201703L
  ${0}
  #endif  // __cplusplus >= 201703L || defined(_MSVC_LANG) && _MSVC_LANG >= 201703L

snippet if_gcc
  #ifdef __GNUC__
  ${0}
  #endif  // __GNUC__

snippet if_msvc
  #ifdef _MSC_VER
  ${0}
  #endif  // _MSC_VER

snippet if_cppcli
  #if defined(_M_CEE) || defined(_MANAGED)
  ${0}
  #endif  // defined(_M_CEE) || defined(_MANAGED)

snippet polyfill_likely
  #if defined(__GNUC__) && (__GNUC__ > 2 || __GNUC__ == 2 && __GNUC_MINOR__ >= 96)
  #  define ${1:#:PREFIX}_LIKELY(cond)  __builtin_expect((cond), 1)
  #else
  #  define $1_LIKELY(cond)  (cond)
  #endif

  ${0}

  #undef $1_LIKELY

snippet polyfill_unlikely
  #if defined(__GNUC__) && (__GNUC__ > 2 || __GNUC__ == 2 && __GNUC_MINOR__ >= 96)
  #  define ${1:#:PREFIX}_UNLIKELY(cond)  __builtin_expect((cond), 0)
  #else
  #  define $1_UNLIKELY(cond)  (cond)
  #endif

  ${0}

  #undef $1_UNLIKELY

snippet polyfill_constexpr_cpp11
  #if __cplusplus >= 201103L || defined(_MSC_VER) && _MSC_VER > 1800
  #  define ${1:#:PREFIX}_CONSTEXPR11 constexpr
  #else
  #  define $1_CONSTEXPR11
  #endif  //  __cplusplus >= 201103L || defined(_MSC_VER) && _MSC_VER > 1800

  ${0}

  #undef $1_CONSTEXPR11

snippet polyfill_constexpr_cpp14
  #if __cplusplus >= 201402L || defined(_MSC_VER) && _MSC_VER > 1900
  #  define ${1:#:PREFIX}_CONSTEXPR14 constexpr
  #else
  #  define $1_CONSTEXPR14
  #endif  //  __cplusplus >= 201402L || defined(_MSC_VER) && _MSC_VER > 1900

  ${0}

  #undef $1_CONSTEXPR14

snippet polyfill_override
  #if __cplusplus >= 201103L \
    || defined(_MSC_VER) && _MSC_VER >= 1500
  #  define ${1:#:NAME}_OVERRIDE  override
  #else
  #  define $1_OVERRIDE
  #endif

  ${0}

  #undef $1_OVERRIDE

snippet polyfill_nullptr
  #if __cplusplus >= 201103L \
    || defined(_MSC_VER) && _MSC_VER >= 1600
  #  define ${1:#:NAME}_NULLPTR  nullptr
  #else
  #  define $1_NULLPTR  NULL
  #endif

  ${0}

  #undef $1_NULLPTR

snippet polyfill_noexcept
  #if __cplusplus >= 201103L \
    || defined(_MSC_VER) && (_MSC_VER > 1800 || _MSC_VER == 1800 && _MSC_FULL_VER == 180021114)
  #  define ${1:#:NAME}_NOEXCEPT  noexcept
  #else
  #  define $1_NOEXCEPT  throw()
  #endif

  ${0}

  #undef $1_NOEXCEPT

snippet def_printf_arg_check
  #if defined(_MSC_VER) && _MSC_VER >= 1400
  #  include <sal.h>
  #  if _MSC_VER > 1400
  #    define ${1:#:PREFIX}_MSVC_CHECK_PRINTF_FMTSTR(fmtarg) _Printf_format_string_ fmtarg
  #  else
  #    define $1_MSVC_CHECK_PRINTF_FMTSTR(fmtarg) __format_string fmtarg
  #  endif  //  _MSC_VER > 1400
  #else
  #  define $1_MSVC_CHECK_PRINTF_FMTSTR(fmtarg) fmtarg
  #endif  // defined(_MSC_VER) && _MSC_VER >= 1400

  #ifdef __GNUC__
  #  define $1_GNUC_CHECK_PRINTF_FMTSTR(index, vaIndex) __attribute__((format(printf, index, vaIndex)))
  #else
  #  define $1_GNUC_CHECK_PRINTF_FMTSTR(index, vaIndex)
  #endif  // __GNUC__

  ${0}

  #undef $1_MSVC_CHECK_PRINTF_FMTSTR
  #undef $1_GNUC_CHECK_PRINTF_FMTSTR

snippet def_scanf_arg_check
  #if defined(_MSC_VER) && _MSC_VER >= 1400
  #  include <sal.h>
  #  if _MSC_VER > 1400
  #    define ${1:#:PREFIX}_MSVC_CHECK_SCANF_FMTSTR(fmtarg) _Scanf_format_string_ fmtarg
  #  else
  #    define $1_MSVC_CHECK_SCANF_FMTSTR(fmtarg) __format_string fmtarg
  #  endif  //  _MSC_VER > 1400
  #else
  #  define $1_MSVC_CHECK_SCANF_FMTSTR(fmtarg) fmtarg
  #endif  // defined(_MSC_VER) && _MSC_VER >= 1400

  #ifdef __GNUC__
  #  define $1_GNUC_CHECK_SCANF_FMTSTR(index, vaIndex) __attribute__((format(scanf, index, vaIndex)))
  #else
  #  define $1_GNUC_CHECK_SCANF_FMTSTR(index, vaIndex)
  #endif  // __GNUC__

  ${0}

  #undef $1_MSVC_CHECK_SCANF_FMTSTR
  #undef $1_GNUC_CHECK_SCANF_FMTSTR

snippet def_assume
  #if defined(_MSC_VER)
  #  define ${1:#:PREFIX}_ASSUME(x)  __assume(x)
  #elif defined(assert)
  #  define $1_ASSUME(x)  assert(x)
  #else
  #  define $1_ASSUME(x)
  #endif  // defined(_MSC_VER)

  ${0}

  #undef $1_ASSUME

snippet supress_warnings_gcc
  #if (defined(__GNUC__) && (__GNUC__ > 4 || __GNUC__ == 4 && __GNUC_MINOR__ >= 6))
  #  define ${1:#:PREFIX}_AVAILABLE_GCC_DIAGNOSTIC_PRAGMA
  #endif

  #ifdef $1_AVAILABLE_GCC_DIAGNOSTIC_PRAGMA
  #  pragma GCC diagnostic push
  #  pragma GCC diagnostic ignored "-Weffc++"
  #  ${0}
  #endif  // $1_AVAILABLE_GCC_DIAGNOSTIC_PRAGMA

  #ifdef $1_AVAILABLE_GCC_DIAGNOSTIC_PRAGMA
  #  pragma GCC diagnostic pop
  #endif  // $1_AVAILABLE_GCC_DIAGNOSTIC_PRAGMA


  #ifdef $1_AVAILABLE_GCC_DIAGNOSTIC_PRAGMA
  #  undef $1_AVAILABLE_GCC_DIAGNOSTIC_PRAGMA
  #endif  // $1_AVAILABLE_GCC_DIAGNOSTIC_PRAGMA

snippet supress_warnings_msvc
  #ifdef _MSC_VER
  #  pragma warning(push)
  #  pragma warning(disable: 4505)
  #endif  // _MSC_VER

  ${0}

  #ifdef _MSC_VER
  #  pragma warning(pop)
  #endif  // _MSC_VER


snippet pragma_comment_lib
  #pragma comment(lib, ${0})

snippet connect
abbr Qt
  connect(${1:#:sender_ptr}, SIGNAL(${2:#:signal}), ${3:#:reciever_ptr}, SLOT(${4:#:slot}))

snippet connect_lambda
abbr Qt
  connect(${1:#:sender_ptr}, ${2:&std\:\:remove_pointer<decltype($1)>\:\:type\:\:${3\:\#\:signal\}}, [${4:#:capture}]${5:(${6:#:args\})}{ ${0} })
