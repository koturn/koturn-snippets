include c.snip

delete main
delete p
delete try

snippet main
  int
  main(${1:int argc, const char* argv[]})
  {
    ${0:TARGET};
    return EXIT_SUCCESS;
  }

snippet cout
  std::cout << ${0:TARGET} << std::endl;

snippet cout2
  std::cout << ${0:TARGET} << '\n';

snippet cout_all
  std::copy(std::cbegin(${1}), std::cend($1), std::ostream_iterator<const decltype($1)::value_type&>(std::cout));

snippet put
  std::cout.put(${0:TARGET})

snippet cerr
  std::cerr << ${0:TARGET} << std::endl;

snippet clog
  std::clog << ${0:TARGET} << std::endl;

snippet cin
  std::cin >> ${0:TARGET};

snippet endl
  std::cout << std::endl;

snippet flush
  std::cout << std::flush;

snippet precision
  std::fixed << std::setprecision(${1}) << ${0:TARGET}

snippet setfill
  std::setw(${1:#:n}) << std::setfill(${2:'0'}) << ${0:TARGET}

snippet fstream
  std::${1:fstream} ${2:fs}(${3:#:filename}${4:, std::ios::binary});
  if (!$2.is_open()) {
    ${5:std\:\:cerr << "Failed to open\: " << $3 << std\:\:endl;}
  }
  ${0:TARGET}

snippet read_all
  std::string ${1:text}((std::istreambuf_iterator<char>(${2:#:stream})), std::istreambuf_iterator<char>())

snippet sleep
  std::this_thread::sleep_for(std::chrono::${1:milliseconds(${2:1000\})});

snippet toppop
  ${1:#:Type} ${2:#:e} = ${3:#:queue}.top(); $3.pop();

snippet itrrange
  ${1}.begin(), $1.end()

snippet constructor
alias ctor
  ${1:#:ClassName}() noexcept ${0:TARGET}

snippet copy_constructor
alias copy_ctor
  ${1:#:ClassName}(const $1& ${2:that}) ${0:TARGET}

snippet move_constructor
alias move_ctor
  ${1:#:ClassName}($1&& ${2:that}) noexcept ${0:TARGET}

snippet destructor
alias dtor
  ~something() noexcept ${0:TARGET}

snippet op_assign
  ${1:#:ClassName}& operator=(const $1&) ${0:TARGET};

snippet op_move_assign
  ${1:#:ClassName}& operator=($1&&) noexcept ${0:TARGET};

snippet numeric_limits
  std::numeric_limits<${1:int}>::${0:TARGET}()

snippet unique_ptr
abbr std::unique_ptr<T> <memory>
  std::unique_ptr<${1}> ${2}(new $1 ${0:TARGET})

snippet shared_ptr
abbr std::shared_ptr<T> <memory>
  std::shared_ptr<${1}> ${2}(new $1 ${0:TARGET})

snippet foreach_iterator
  for (std::${1:vector}<${2}>::iterator ${3:itr} = ${4}.begin(); $3 != $4.end(); ++$3) {
    ${0:TARGET}
  }

snippet string
abbr std::string <string>
  std::string ${0:TARGET}

snippet complex
abbr std::complex<T> <complex>
  std::complex<${1:double}> ${0:TARGET}

snippet array
abbr std::array<T, N> <array>
  std::array<${1:int}, ${2:#:N}> ${0:TARGET}

snippet vector
abbr std::vector<T> <vector>
  std::vector<${1:int}> ${0:TARGET}

snippet valarray
abbr std::valarray<T> <valarray>
  std::valarray<${1:int}> ${0:TARGET}

snippet bitset
abbr std::bitset<N> <bitset>
  std::bitset<${1:8}> ${0:TARGET}

snippet list
abbr std::list<T> <list>
  std::list<${1:int}> ${0:TARGET}

snippet forward_list
abbr std::forward_list<T> <forward_list>
  std::forward_list<${1:int}> ${0:TARGET}

snippet deque
abbr std::deque<T> <deque>
  std::deque<${1:int}> ${0:TARGET}

snippet stack
abbr std::stack<T> <stack>
  std::stack<${1:int}> ${0:TARGET}

snippet queue
abbr std::queue<T> <queue>
  std::queue<${1:int}> ${0:TARGET}

snippet priority_queue
abbr std::priority_queue<T> <queue>
  std::priority_queue<${1:int}> ${0:TARGET}

snippet priority_queue2
abbr std::priority_queue<T> <queue>
  std::priority_queue<${1:int}, std::vector<$1>, std::function<bool (const $1& x, const $1& y)> > ${2}(
      [](const $1& x, const $1& y) {
        ${0:#:return x > y;}
      })

snippet map
abbr std::map<K, V> <map>
  std::map<${1:int}, ${2:int}> ${0:TARGET}

snippet unordered_map
abbr std::unordered_map<K, V> <unordered_map>
  std::unordered_map<${1:int}, ${2:int}> ${0:TARGET}

snippet multimap
abbr std::multimap<K, V> <map>
  std::multimap<${1:int}, ${2:int}> ${0:TARGET}

snippet unordered_multimap
abbr std::unordered_multimap<K, V> <unordered_map>
  std::unordered_multimap<${1:int}, ${2:int}> ${0:TARGET}

snippet set
abbr std::set<T> <set>
  std::set<${1:int}> ${0:TARGET}

snippet unordered_set
abbr std::unordered_set<T> <unordered_set>
  std::unordered_set<${1:int}> ${0:TARGET}

snippet multiset
abbr std::multiset<T> <set>
  std::multiset<${1:int}> ${0:TARGET}

snippet unordered_multiset
abbr std::unordered_multiset<T> <unordered_set>
  std::unordered_multiset<${1:int}> ${0:TARGET}

snippet pair
abbr std::pair<T1, T2> <utility>
  std::pair<${1:int}, ${2:int}> ${0:TARGET}

snippet initializer_list
abbr std::initializer_list<T> <initializer_list>
  std::initializer_list<${1:int}> ${0:TARGET}

snippet array2d
abbr std::array<std::array<T, W>, H> <array>
  std::array<std::array<${1:int}, ${3:#:W}>, ${2:#:H}> ${0:TARGET}

snippet vector2d
abbr std::vector<std::vector<T> > <vector>
  std::vector<std::vector<${1:int}> > ${2:#:varname}(${3:#:height}, std::vector<$1>(${4:#:width}))

snippet valarray2d
abbr std::vector<std::valarray<T> > <valarray>
  std::vector<std::valarray<${1:int}> > ${2:#:varname}(${3:#:height}, std::valarray<$1>(${4:#:width}))

snippet random
  std::${1:mt19937} ${2:rnd}((std::random_device())())

snippet enable_if
  typename std::enable_if<${0:TARGET}, std::nullptr_t>::type = nullptr

snippet remove_reference
  std::remove_reference<${0:TARGET}>::type

snippet thread
  std::thread ${1:#:name}([${2:&}]{
    ${0:TARGET}
  });

snippet async
  std::async ${1:#:name}(std::launch::async, [${2:&}]{
    ${0:TARGET}
  });

snippet fn
  ${1:#:rettype}
  ${2:#:fucname}()${3: noexcept}
  {
    ${0:TARGET}
  }

snippet fn_auto
  auto
  ${2:#:fucname}()${3: noexcept} -> ${1:#:rettype}
  {
    ${0:TARGET}
  }

snippet foreach_const_iterator
  for (std::${1:vector}<${2}>::const_iterator ${3:itr} = ${4}.begin(); $3 != $4.end(); ++$3) {
    ${0:TARGET}
  }

snippet foreach_typeof
abbr foreach_typeof (GNU only)
  for (typeof(${1}.begin()) ${2:itr} = $1.begin(); $2 != $1.end(); ++$2) {
    ${0:TARGET}
  }

snippet forref
  for (auto&& ${1:e} : ${2:#:container}) {
    ${0:TARGET}
  }

snippet forref_c
  for (const auto& ${1:e} : ${2:#:container}) {
    ${0:TARGET}
  }

snippet try
  try {
    ${0:TARGET}
  } catch (${1:const std::exception&} ${2:e}) {
    ${3:std::cerr << $2.what() << std::endl;}
  }

snippet struct_function_object
abbr Functional object
  struct ${1}
  {
    ${2}
    operator()(${3}) const
    {
      ${0:TARGET}
    }
  };

snippet class_functional_object
abbr Functional object
  class ${1}
  {
  public:
    ${2} operator()(${3}) const
    {
      ${0:TARGET}
    }
  };

snippet for_each
abbr std::for_each <algorithm>
  std::for_each(
      std::begin(${1}),
      std::end($1),
      [](const decltype($1)::value_type& ${2:e}) {
        ${0:TARGET}
      })

snippet all_of
abbr std::all_of <algorithm>
  std::all_of(
      std::cbegin(${1}),
      std::cend($1),
      [](const decltype($1)::value_type& ${2:e}) {
        return ${0:TARGET};
      })

snippet none_of
abbr std::none_of <algorithm>
  std::none_of(
      std::cbegin(${1}),
      std::cend($1),
      [](const decltype($1)::value_type& ${2:e}) {
        return ${0:TARGET};
      })

snippet any_of
abbr std::any_of <algorithm>
  std::any_of(
      std::cbegin(${1}),
      std::cend($1),
      [](const decltype($1)::value_type& ${2:e}) {
        return ${0:TARGET};
      })

snippet sort
abbr std::sort <algorithm>
  std::sort(std::begin(${1}), std::end($1))

snippet sort_p
abbr std::sort <algorithm>
  std::sort(
      std::begin(${1}),
      std::end($1),
      [](const decltype($1)::value_type& x, const decltype($1)::value_type& y) {
        return ${0:#:x < y};
      })

snippet stable_sort
abbr std::stable_sort <algorithm>
  std::stable_sort(std::begin(${1}), std::end($1))

snippet stable_sort_p
abbr std::stable_sort <algorithm>
  std::stable_sort(
      std::begin(${1}),
      std::end($1),
      [](const decltype($1)::value_type& x, const decltype($1)::value_type& y) {
        return ${0:#:x < y};
      })

snippet shuffle
abbr std::shuffle <algorithm> <random>
  std::shuffle(std::begin(${1}), std::end($1), ${2:std\:\:mt19937()})

snippet partial_sum
abbr std::partial_sum <numeric>
  std::partial_sum(std::cbegin(${1}), std::cend($1), std::begin(${2}));

snippet min_element
abbr std::min_element <algorithm>
  std::min_element(std::cbegin(${1}), std::cend($1))

snippet min_element_p
abbr std::min_element <algorithm>
  std::min_element(
      std::cbegin(${1}),
      std::cend($1),
      [](const decltype($1)::value_type& x, const decltype($1)::value_type& y) {
        return ${0:#:x < y};
      })

snippet max_element
abbr std::max_element <algorithm>
  std::max_element(std::cbegin(${1}), std::cend($1))

snippet max_element_p
abbr std::max_element <algorithm>
  std::max_element(
      std::cbegin(${1}),
      std::cend($1),
      [](const decltype($1)::value_type& x, const decltype($1)::value_type& y) {
        return ${0:#:x < y};
      })

snippet minmax_element
abbr std::minmax_element <algorithm>
  std::minmax_element(std::cbegin(${1}), std::cend($1))

snippet minmax_element_p
abbr std::minmax_element <algorithm>
  std::minmax_element(
      std::cbegin(${1}),
      std::cend($1),
      [](const decltype($1)::value_type& x, const decltype($1)::value_type& y) {
        return ${0:#:x < y};
      })

snippet iota
abbr std::iota <numeric>
  std::iota(std::begin(${1}), std::end($1), ${2:0})

snippet generate
alias generate_p
abbr std::generate <algorithm>
  std::generate(
      std::begin(${1}),
      std::end($1),
      []{
        return ${0:TARGET};
      })

snippet generate_n
alias generate_n_p
  std::generate(
      ${1:#:begin},
      ${2:#:size},
      []{
        return ${0:TARGET};
      })

snippet fill
abbr std::fill <algorithm>
  std::fill(std::begin(${1}), std::end($1), ${2:#:0})

snippet fill_n
abbr std::fill_n <algorithm>
  std::fill_n(${1:#:begin}, ${2:#:size}, ${3:#:0})

snippet count
abbr std::count <algorithm>
  std::count(std::cbegin(${1}), std::cend($1), ${2:#:value})

snippet count_if
alias count_p
abbr std::count_if <algorithm>
  std::count_if(
      std::cbegin(${1}),
      std::cend($1),
      [](const decltype($1)::value_type& ${2:e}) {
        return ${0:TARGET};
      })

snippet find
abbr std::find <algorithm>
  std::find(std::cbegin(${1}), std::cend($1), ${2:#:value})

snippet find_if
alias find_p
abbr std::find_if <algorithm>
  std::find_if(
      std::cbegin(${1}),
      std::cend($1),
      [](const decltype($1)::value_type& ${2:e}) {
        return ${0:TARGET};
      })

snippet remove
abbr std::remove <algorithm>
  std::remove(std::begin(${1}), std::end($1), ${2:#:value})

snippet remove_if
alias remove_p
abbr std::remove_if <algorithm>
  std::remove_if(
      std::begin(${1}),
      std::end($1),
      [](const decltype($1)::value_type& ${2:e}) {
        return ${0:TARGET};
      })

snippet remove_erase
  ${1}.erase(std::remove(std::begin($1), std::end($1), ${2:#:value}), std::end($1));

snippet remove_erase_if
alias remove_erase_p filter select
  ${1}.erase(
      std::remove_if(
        std::begin($1),
        std::end($1),
        [](const decltype($1)::value_type& ${2:e}) {
          return ${0:TARGET};
        }),
      std::end($1))

snippet unique
abbr std::unique <algorithm>
  std::unique(std::begin(${1}), std::end($1))

snippet unique_p
abbr std::unique <algorithm>
  std::unique(
      std::begin(${1}),
      std::end($1),
      [](const decltype($1)::value_type& ${2:x}, const decltype($1)::value_type& ${3:y}) {
        return ${0:#:x == y};
      })

snippet unique_erase
  ${1}.erase(std::unique(std::begin($1), std::end($1)), std::end($1));

snippet unique_erase_p
  ${1}.erase(
      std::unique(
        std::begin($1),
        std::end($1),
        [](const decltype($1)::value_type& ${2:x}, const decltype($1)::value_type& ${3:y}) {
          return ${0:#:x == y};
        }),
      std::end($1))

snippet copy
abbr std::copy <algorithm>
  std::copy(std::cbegin(${1}), std::cend($1), std::begin(${2}))

snippet copy_backward
abbr std::copy_backword <algorithm>
  std::copy_backward(std::cbegin(${1}), std::cend($1), std::begin(${2}))

snippet copy_n
abbr std::copy_n <algorithm>
  std::copy_n(std::cbegin(${1}), ${2:#:size}, std::begin(${3}))

snippet copy_if
alias copy_p
abbr std::copy_if <algorithm>
  std::copy_if(
      std::cbegin(${1}),
      std::cend($1),
      std::begin(${2}),
      [](const decltype($1)::value_type& ${3:e}) {
        return ${0:TARGET};
      })

snippet replace
abbr std::replace <algorithm>
  std::replace(std::begin(${1}), std::end($1), ${2:#:before}, ${3:#:after})

snippet replace_if
alias replace_p
abbr std::replace_if <algorithm>
  std::replace_if(
      std::begin(${1}),
      std::end($1),
      [](const decltype($1)::value_type& ${3:e}) {
        return ${0:TARGET};
      }, ${2:#:after})

snippet sum
alias foldl
  std::accumulate(std::cbegin(${1}), std::cend($1), ${2:decltype($1)::value_type()})

snippet foldr
  std::accumulate(
      std::crbegin(${1}),
      std::crend($1),
      ${2:decltype($1)::value_type()},
      [](const decltype($1)::value_type& ${3:acc}, const decltype($1)::value_type& ${4:e}) {
        return $4 + acc;
      })

snippet accumulate
alias accumulate_p reduce
abbr std::acumulate <numeric>
  std::accumulate(
      std::cbegin(${1}),
      std::cend($1),
      ${2:decltype($1)::value_type()},
      [](const decltype($1)::value_type& ${3:acc}, const decltype($1)::value_type& ${4:e}) {
        return ${5:acc + $4};
      })

snippet inner_product
abbr std::inner_product <numeric>
  std::inner_product(std::cbegin(${1}), std::cend($1), std::cbegin(${2}), ${3:decltype($1)::value_type()})

snippet transform
alias transform_p map_set select
abbr std::transform <algorithm>
  std::transform(
      std::cbegin(${1}),
      std::cend($1),
      std::begin(${2}),
      [](const decltype($1)::value_type& ${3:e}) {
        return ${0:TARGET};
      })

snippet tolower_string
  std::transform(std::cbegin(${1}), std::cend($1), std::begin($1), static_cast<int (*)(int)>(std::tolower));

snippet toupper_string
  std::transform(std::cbegin(${1}), std::cend($1), std::begin($1), static_cast<int (*)(int)>(std::toupper));

snippet next_permutation
  do {
    ${0:TARGET}
  } while (std::next_permutation(std::begin(${1}), std::end($1)));

snippet time_measurement
  std::chrono::system_clock::time_point ${1:start} = std::chrono::system_clock::now();
  ${0:TARGET};
  double ${2:elapsed} = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now() - $1).count();

snippet duration_cast
abbr std::chrono::duration_cast<T>() <chrono>
  std::chrono::duration_cast<std::chrono::${1:milliseconds}>(${2})

snippet lock_guard
  {
    std::lock_guard<decltype($2)> ${1:lock}(${2:#:mutex});
    ${0:TARGET}
  }

snippet lock_guard_adopt
  {
    std::lock_guard<decltype($2)> ${1:lock}(${2:#:mutex}, std::adopt_lock);
    ${0:TARGET}
  }

snippet update_min
  ${1:#:minValue} = std::min($1, ${2:#:newValue})

snippet update_max
  ${1:#:maxValue} = std::max($1, ${2:#:newValue})

snippet update_min_if
  if (${1:#:minValue} > ${2:#:newValue}) {
    $1 = $2;
    ${0:TARGET}
  }

snippet update_max_if
  if (${1:#:maxValue} < ${2:#:newValue}) {
    $1 = $2;
    ${0:TARGET}
  }

snippet include
  #include <${0:TARGET}>

snippet include_math
  #ifdef _MSC_VER
  #  define _USE_MATH_DEFINES
  #endif
  #include <cmath>

snippet constant
  static constexpr ${1:int} ${2:#:varname} = ${3:#:value}

snippet LOOP
alias loop
  LOOP (${2:#:n}) {
    ${0:TARGET}
  }

snippet REP
alias rep
  REP (${1:i}, ${2:#:n}) {
    ${0:TARGET}
  }

snippet FOR
  FOR (${1:i}, ${2:#:from}, ${3:#:to}) {
    ${0:TARGET}
  }

snippet def_LOOP
  #define LOOP(n)  for (decltype(n) __loop_tmp_var__ = 0; i < n; i++)

snippet def_REP
  #define REP(i, n)  for (decltype(n) i = 0; i < n; i++)

snippet def_FOR
  #define FOR(i, from, to)  for (decltype(from) i = from; i < to; i++)

snippet def_CLEAR
  #define CLEAR(array)  std::memset((array), 0, sizeof(array))

snippet def_FILL
  #define FILL(array, val)  std::fill_n(array, LENGTH(array), val)

snippet def_enum
  #if __cplusplus >= 201103L
  enum class ${1:className}
  {
    ${2:enumValues}
  };  // enum class $1
  #else
  class $1
  {
  public:
    enum $1Enum
    {
      $2
    };
    $1($1Enum value) :
      value(value)
    {}
    operator $1Enum() const throw()
    {
      return value;
    }
  private:
    $1Enum value;
  };  // class $1
  #endif  // __cplusplus >= 201103L

snippet def_debug_macros
  #ifdef _MSC_VER
  #  ifndef _DEBUG
  #    define _DEBUG
  #  endif
  #  define _CRTDBG_MAP_ALLOC
  #else
  #  define _FORTIFY_SOURCE 2
  #  define _GLIBCXX_DEBUG
  #endif

snippet def_INF
  static constexpr ${1:int} INF = 0x3f3f3f3f;

snippet def_EPS
  static constexpr double EPS = 1.0e-${1:9};

snippet def_M_PI
  #ifndef M_PI
  static const double M_PI = std::acos(0.0) * 2.0;
  #endif

snippet def_M_PI2
  #ifndef M_PI
  static const double M_PI = std::atan(1.0) * 4.0;
  #endif

snippet def_M_PI3
  #ifndef M_PI
  static constexpr double M_PI = 3.14159265358979323846;
  #endif

snippet def_DUMP
  #define DUMP(x)  (std::cout << #x " = " << x << std::endl)

snippet impl_to_string
  #if __cplusplus < 201103L || defined(__CYGWIN__)
  #  include <sstream>
  namespace std {
  template<typename T>
  static std::string
  to_string(const T& x)
  {
    static std::ostringstream oss;
    oss.str("");
    oss.clear(std::ostringstream::goodbit);
    oss << x;
    return oss.str();
  }
  }  // namespace std
  #endif

snippet impl_stoi
  #if __cplusplus < 201103L || defined(__CYGWIN__)
  #  include <sstream>
  namespace std
  {
  static int
  stoi(const string& str)
  {
    int x;
    stringstream ss;
    ss << str;
    ss >> x;
    ss.str("");
    ss.clear(std::stringstream::goodbit);
    return x;
  }
  }  // namespace std
  #endif

snippet impl_gcd
  template<typename IntType, typename std::enable_if<std::is_integral<IntType>::value, std::nullptr_t>::type = nullptr>
  static inline IntType
  gcd(IntType a, IntType b)
  {
  #ifdef __GNUC__
    return std::__gcd(a, b);  // <algorithm>
  #else
    IntType r;
    while ((r = a % b) != 0) {
      a = b;
      b = r;
    }
    return a;
  #endif
  }

snippet impl_lcm
  template<typename IntType, typename std::enable_if<std::is_integral<IntType>::value, std::nullptr_t>::type = nullptr>
  static inline IntType
  lcm(IntType a, IntType b)
  {
    return a / gcd(a, b) * b;
  }

snippet impl_powmod
  template<typename IntType, typename std::enable_if<std::is_integral<IntType>::value, std::nullptr_t>::type = nullptr>
  static IntType
  powmod(IntType a, int p, IntType mod)
  {
    IntType ans = 1, mul = a;
    for (; p > 0; p >>= 1, mul = (mul * mul) % mod) {
      if ((p & 1) == 1) {
        ans = (ans * mul) % mod;
      }
    }
    return ans;
  }

snippet impl_popcnt
  #ifdef __GNUC__
  #  define popcnt(n)  __builtin_popcount(n)
  #else
  static unsigned int
  popcnt(unsigned int n)
  {
    unsigned int cnt = 0;
    while (n != 0) {
      cnt += (n & 0x01);
      n >>= 1;
    }
  }
  #endif

snippet impl_split
  static std::vector<std::string>
  split(const std::string& str, char delim)
  {
    std::vector<std::string> tokens;
    std::string::size_type spos = 0, epos;
    while ((epos = str.find_first_of(delim, spos)) != std::string::npos) {
      tokens.push_back(std::string(str, spos, epos - spos));
      spos = epos + 1;
    }
    tokens.push_back(std::string(str, spos, str.size() - spos));
    return tokens;
  }

  static std::vector<std::string>
  split(const std::string& str, const std::string &delim)
  {
    std::vector<std::string> tokens;
    std::string::size_type spos = 0, epos, delimlen = delim.size();
    while ((epos = str.find(delim, spos)) != std::string::npos) {
      tokens.push_back(std::string(str, spos, epos - spos));
      spos = epos + delimlen;
    }
    tokens.push_back(std::string(str, spos, str.size() - spos));
    return tokens;
  }

snippet impl_LENGTH
abbr #define LENGTH
  template<typename ${1:Type}, std::size_t ${2:SIZE}>
  static std::size_t
  LENGTH(const $1 (&)[$2])
  {
    return $2;
  }

  #if __cplusplus >= 201103L
  template<typename $1, std::size_t $2>
  static typename std::array<$1, $2>::size_type
  LENGTH(const std::array<$1, $2>& ${3:array})
  {
    return $3.size();
  }
  #endif


snippet impl_modfact
  template<typename IntType, typename std::enable_if<std::is_integral<IntType>::value, std::nullptr_t>::type = nullptr>
  static IntType
  modfact(IntType n, IntType mod)
  {
    IntType p = 1;
    for (; n > 0; n--) {
      p = (p * n) % mod;
    }
    return p;
  }

snippet impl_extgcd
  template<typename IntType, typename std::enable_if<std::is_integral<IntType>::value, std::nullptr_t>::type = nullptr>
  static IntType
  extgcd(IntType a, IntType b, IntType& x, IntType& y)
  {
    IntType v = x = 0;
    IntType u = y = 1;
    while (a != 0) {
      IntType q = b / a;
      std::swap(x -= q * u, u);
      std::swap(y -= q * v, v);
      std::swap(b -= q * a, a);
    }
    return b;
  }

snippet impl_modinv
  template<typename IntType, typename std::enable_if<std::is_integral<IntType>::value, std::nullptr_t>::type = nullptr>
  static IntType
  modinv(IntType a, IntType mod)
  {
    IntType x, y;
    extgcd(a, mod, x, y);
    return (mod + x % mod) % mod;
  }

snippet if_cpp11
  #if __cplusplus >= 201103L
  ${0:TARGET}
  #endif

snippet if_cpp14
  #if __cplusplus >= 201402L
  ${0:TARGET}
  #endif

snippet if_gcc
  #ifdef __GNUC__
  ${0:TARGET}
  #endif

snippet if_msvc
  #ifdef _MSC_VER
  ${0:TARGET}
  #endif

snippet connect
abbr Qt
  connect(${1:#:sender_ptr}, SIGNAL(${2:#:signal}), ${3:#:reciever_ptr}, SLOT(${4:#:slot}))

snippet connect_lambda
abbr Qt
  connect(${1:#:sender_ptr}, ${2:&std\:\:remove_pointer<decltype($1)>\:\:type\:\:${3\:\#\:signal\}}, [${4:#:capture}]${5:(${6:#:args\})}{ ${0:TARGET} })
